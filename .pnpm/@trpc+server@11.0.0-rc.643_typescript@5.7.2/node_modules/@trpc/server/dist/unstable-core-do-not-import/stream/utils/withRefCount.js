'use strict';

// Callback function type that is called when a collection is drained
function withRefCount(_obj, onDrain) {
    const obj = _obj;
    // Track whether the collection has been drained
    let drained = false;
    // Track whether the collection has been activated
    let active = false;
    // Check if collection should be drained (empty and active)
    const checkDrain = ()=>{
        if (!drained && active && obj.size === 0) {
            onDrain();
            drained = true;
        }
    };
    // Create proxy to intercept collection operations
    return new Proxy(obj, {
        get (_, prop) {
            // Handle activation
            if (prop === 'activate') {
                return ()=>{
                    active = true;
                    checkDrain();
                };
            }
            // Handle adding items - prevent if already drained
            if (prop === 'set' || prop === 'add') {
                return (...args)=>{
                    if (drained) {
                        throw new Error('Already drained');
                    }
                    return obj[prop](...args);
                };
            }
            // Handle removing items - check if should drain after
            if (prop === 'delete' || prop === 'clear') {
                return (...args)=>{
                    try {
                        return obj[prop](...args);
                    } finally{
                        checkDrain();
                    }
                };
            }
            // Pass through other method calls
            const target = obj[prop];
            if (typeof target === 'function') {
                return (...args)=>{
                    return obj[prop](...args);
                };
            }
            // Pass through property access
            return target;
        }
    });
}

exports.withRefCount = withRefCount;
