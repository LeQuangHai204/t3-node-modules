'use strict';

var unpromise = require('../../vendor/unpromise/unpromise.js');
var TRPCError = require('../error/TRPCError.js');
var isAbortError = require('../http/isAbortError.js');
var utils = require('../utils.js');
var tracked = require('./tracked.js');
var asyncIterable = require('./utils/asyncIterable.js');
var createReadableStream = require('./utils/createReadableStream.js');
var withPing = require('./utils/withPing.js');

const PING_EVENT = 'ping';
const SERIALIZED_ERROR_EVENT = 'serialized-error';
const CONNECTED_EVENT = 'connected';
/**
 *
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html
 */ function sseStreamProducer(opts) {
    const stream = createReadableStream.createReadableStream();
    const { serialize = utils.identity } = opts;
    const ping = {
        enabled: opts.ping?.enabled ?? false,
        intervalMs: opts.ping?.intervalMs ?? 1000
    };
    const client = opts.client ?? {};
    stream.controller.enqueue({
        event: CONNECTED_EVENT,
        data: JSON.stringify(client)
    });
    if (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) {
        throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);
    }
    utils.run(async ()=>{
        let iterable = opts.data;
        if (opts.emitAndEndImmediately) {
            iterable = asyncIterable.takeWithGrace(iterable, {
                count: 1,
                gracePeriodMs: 1
            });
        }
        if (opts.maxDurationMs && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) {
            iterable = asyncIterable.withMaxDuration(iterable, {
                maxDurationMs: opts.maxDurationMs
            });
        }
        if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) {
            iterable = withPing.withPing(iterable, ping.intervalMs);
        }
        try {
            // We need those declarations outside the loop for garbage collection reasons. If they were
            // declared inside, they would not be freed until the next value is present.
            let value;
            let chunk;
            for await (value of iterable){
                if (value === withPing.PING_SYM) {
                    stream.controller.enqueue({
                        event: PING_EVENT,
                        data: ''
                    });
                    continue;
                }
                chunk = tracked.isTrackedEnvelope(value) ? {
                    id: value[0],
                    data: value[1]
                } : {
                    data: value
                };
                if ('data' in chunk) {
                    chunk.data = JSON.stringify(serialize(chunk.data));
                }
                stream.controller.enqueue(chunk);
                // free up references for garbage collection
                value = null;
                chunk = null;
            }
        } catch (err) {
            if (isAbortError.isAbortError(err)) {
                // ignore abort errors, send any other errors
                return;
            }
            // `err` must be caused by `opts.data`, `JSON.stringify` or `serialize`.
            // So, a user error in any case.
            const error = TRPCError.getTRPCErrorFromUnknown(err);
            const data = opts.formatError?.({
                error
            }) ?? null;
            stream.controller.enqueue({
                event: SERIALIZED_ERROR_EVENT,
                data: JSON.stringify(serialize(data))
            });
        } finally{
            try {
                stream.controller.close();
            } catch  {
            // ignore
            }
        }
    }).catch((err)=>{
        // should not be reached; just in case...
        stream.controller.error(err);
    });
    return stream.readable.pipeThrough(new TransformStream({
        transform (chunk, controller) {
            if ('event' in chunk) {
                controller.enqueue(`event: ${chunk.event}\n`);
            }
            if ('data' in chunk) {
                controller.enqueue(`data: ${chunk.data}\n`);
            }
            if ('id' in chunk) {
                controller.enqueue(`id: ${chunk.id}\n`);
            }
            if ('comment' in chunk) {
                controller.enqueue(`: ${chunk.comment}\n`);
            }
            controller.enqueue('\n\n');
        }
    }));
}
async function withTimeout(opts) {
    let timeoutId;
    const timeoutPromise = new Promise((resolve)=>{
        timeoutId = setTimeout(()=>{
            resolve(null);
        }, opts.timeoutMs);
    });
    let res;
    try {
        res = await unpromise.Unpromise.race([
            opts.promise,
            timeoutPromise
        ]);
    } finally{
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        clearTimeout(timeoutId);
    }
    if (res === null) {
        return await opts.onTimeout();
    }
    return res;
}
/**
 * @see https://html.spec.whatwg.org/multipage/server-sent-events.html
 */ function sseStreamConsumer(opts) {
    const { deserialize = (v)=>v } = opts;
    let clientOptions = {};
    const signal = opts.signal;
    let _es = null;
    const createStream = ()=>new ReadableStream({
            async start (controller) {
                const [url, init] = await Promise.all([
                    opts.url(),
                    opts.init()
                ]);
                const eventSource = _es = new opts.EventSource(url, init);
                controller.enqueue({
                    type: 'connecting',
                    eventSource: _es,
                    event: null
                });
                eventSource.addEventListener(CONNECTED_EVENT, (_msg)=>{
                    const msg = _msg;
                    const options = JSON.parse(msg.data);
                    clientOptions = options;
                    controller.enqueue({
                        type: 'connected',
                        options,
                        eventSource
                    });
                });
                eventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg)=>{
                    const msg = _msg;
                    controller.enqueue({
                        type: 'serialized-error',
                        error: deserialize(JSON.parse(msg.data)),
                        eventSource
                    });
                });
                eventSource.addEventListener(PING_EVENT, ()=>{
                    controller.enqueue({
                        type: 'ping',
                        eventSource
                    });
                });
                eventSource.addEventListener('error', (event)=>{
                    if (eventSource.readyState === EventSource.CLOSED) {
                        controller.error(event);
                    } else {
                        controller.enqueue({
                            type: 'connecting',
                            eventSource,
                            event
                        });
                    }
                });
                eventSource.addEventListener('message', (_msg)=>{
                    const msg = _msg;
                    const chunk = deserialize(JSON.parse(msg.data));
                    const def = {
                        data: chunk
                    };
                    if (msg.lastEventId) {
                        def.id = msg.lastEventId;
                    }
                    controller.enqueue({
                        type: 'data',
                        data: def,
                        eventSource
                    });
                });
                const onAbort = ()=>{
                    controller.close();
                    eventSource.close();
                };
                if (signal.aborted) {
                    onAbort();
                } else {
                    signal.addEventListener('abort', onAbort);
                }
            },
            cancel () {
                _es?.close();
            }
        });
    const getNewStreamAndReader = ()=>{
        const stream = createStream();
        const reader = stream.getReader();
        return {
            reader,
            cancel: ()=>{
                reader.releaseLock();
                return stream.cancel();
            }
        };
    };
    return {
        [Symbol.asyncIterator] () {
            let stream = getNewStreamAndReader();
            const iterator = {
                async next () {
                    let promise = stream.reader.read();
                    const timeoutMs = clientOptions.reconnectAfterInactivityMs;
                    if (timeoutMs) {
                        promise = withTimeout({
                            promise,
                            timeoutMs,
                            onTimeout: async ()=>{
                                // Close and release old reader
                                await stream.cancel();
                                // Create new reader
                                stream = getNewStreamAndReader();
                                return {
                                    value: {
                                        type: 'timeout',
                                        ms: timeoutMs,
                                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                        eventSource: _es
                                    },
                                    done: false
                                };
                            }
                        });
                    }
                    const result = await promise;
                    // console.debug('result', result, 'done', result.done);
                    if (result.done) {
                        return {
                            value: result.value,
                            done: true
                        };
                    }
                    return {
                        value: result.value,
                        done: false
                    };
                },
                async return () {
                    await stream.cancel();
                    return {
                        value: undefined,
                        done: true
                    };
                }
            };
            return iterator;
        }
    };
}
const sseHeaders = {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache, no-transform',
    'X-Accel-Buffering': 'no',
    Connection: 'keep-alive'
};

exports.sseHeaders = sseHeaders;
exports.sseStreamConsumer = sseStreamConsumer;
exports.sseStreamProducer = sseStreamProducer;
