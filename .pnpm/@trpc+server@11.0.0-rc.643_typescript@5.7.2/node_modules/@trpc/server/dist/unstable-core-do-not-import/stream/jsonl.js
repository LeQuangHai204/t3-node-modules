'use strict';

var _define_property = require('../../node_modules/.pnpm/@swc_helpers@0.5.13/node_modules/@swc/helpers/esm/_define_property.js');
var utils = require('../utils.js');
var createDeferred = require('./utils/createDeferred.js');
var createReadableStream = require('./utils/createReadableStream.js');
var withRefCount = require('./utils/withRefCount.js');

// ---------- types
const CHUNK_VALUE_TYPE_PROMISE = 0;
const CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;
const PROMISE_STATUS_FULFILLED = 0;
const PROMISE_STATUS_REJECTED = 1;
const ASYNC_ITERABLE_STATUS_RETURN = 0;
const ASYNC_ITERABLE_STATUS_VALUE = 1;
const ASYNC_ITERABLE_STATUS_ERROR = 2;
function isPromise(value) {
    return (utils.isObject(value) || utils.isFunction(value)) && typeof value?.['then'] === 'function' && typeof value?.['catch'] === 'function';
}
class MaxDepthError extends Error {
    constructor(path){
        super('Max depth reached at path: ' + path.join('.')), _define_property._(this, "path", void 0), this.path = path;
    }
}
function createBatchStreamProducer(opts) {
    const { data } = opts;
    let counter = 0;
    const placeholder = 0;
    const stream = createReadableStream.createReadableStream();
    const pending = withRefCount.withRefCount(new Set(), ()=>{
        if (!stream.cancelled()) {
            stream.controller.close();
        }
    });
    const maybeEnqueue = (chunk)=>{
        if (!stream.cancelled()) {
            stream.controller.enqueue(chunk);
        }
    };
    function encodePromise(promise, path) {
        const error = checkMaxDepth(path);
        if (error) {
            // Catch any errors from the original promise to ensure they're reported
            promise.catch((cause)=>{
                opts.onError?.({
                    error: cause,
                    path
                });
            });
            // Replace the promise with a rejected one containing the max depth error
            promise = Promise.reject(error);
        }
        const idx = counter++;
        pending.add(idx);
        promise.then((it)=>{
            maybeEnqueue([
                idx,
                PROMISE_STATUS_FULFILLED,
                encode(it, path)
            ]);
        }).catch((cause)=>{
            opts.onError?.({
                error: cause,
                path
            });
            maybeEnqueue([
                idx,
                PROMISE_STATUS_REJECTED,
                opts.formatError?.({
                    error: cause,
                    path
                })
            ]);
        }).finally(()=>{
            pending.delete(idx);
        });
        return idx;
    }
    function encodeAsyncIterable(iterable, path) {
        const idx = counter++;
        pending.add(idx);
        utils.run(async ()=>{
            const error = checkMaxDepth(path);
            if (error) {
                throw error;
            }
            const iterator = iterable[Symbol.asyncIterator]();
            while(true){
                if (stream.cancelled()) {
                    const res = await iterator.return?.();
                    return res?.value;
                }
                const next = await iterator.next();
                if (next.done) {
                    maybeEnqueue([
                        idx,
                        ASYNC_ITERABLE_STATUS_RETURN,
                        encode(next.value, path)
                    ]);
                    break;
                }
                maybeEnqueue([
                    idx,
                    ASYNC_ITERABLE_STATUS_VALUE,
                    encode(next.value, path)
                ]);
            }
        }).catch((cause)=>{
            opts.onError?.({
                error: cause,
                path
            });
            maybeEnqueue([
                idx,
                ASYNC_ITERABLE_STATUS_ERROR,
                opts.formatError?.({
                    error: cause,
                    path
                })
            ]);
        }).finally(()=>{
            pending.delete(idx);
        });
        return idx;
    }
    function checkMaxDepth(path) {
        if (opts.maxDepth && path.length > opts.maxDepth) {
            return new MaxDepthError(path);
        }
        return null;
    }
    function encodeAsync(value, path) {
        if (isPromise(value)) {
            return [
                CHUNK_VALUE_TYPE_PROMISE,
                encodePromise(value, path)
            ];
        }
        if (utils.isAsyncIterable(value)) {
            if (opts.maxDepth && path.length >= opts.maxDepth) {
                throw new Error('Max depth reached');
            }
            return [
                CHUNK_VALUE_TYPE_ASYNC_ITERABLE,
                encodeAsyncIterable(value, path)
            ];
        }
        return null;
    }
    function encode(value, path) {
        if (value === undefined) {
            return [
                []
            ];
        }
        if (!utils.isObject(value)) {
            return [
                [
                    value
                ]
            ];
        }
        const reg = encodeAsync(value, path);
        if (reg) {
            return [
                [
                    placeholder
                ],
                [
                    null,
                    ...reg
                ]
            ];
        }
        const newObj = {};
        const asyncValues = [];
        for (const [key, item] of Object.entries(value)){
            const transformed = encodeAsync(item, [
                ...path,
                key
            ]);
            if (!transformed) {
                newObj[key] = item;
                continue;
            }
            newObj[key] = placeholder;
            asyncValues.push([
                key,
                ...transformed
            ]);
        }
        return [
            [
                newObj
            ],
            ...asyncValues
        ];
    }
    const newHead = {};
    for (const [key, item] of Object.entries(data)){
        newHead[key] = encode(item, [
            key
        ]);
    }
    pending.activate();
    return [
        newHead,
        stream.readable
    ];
}
/**
 * JSON Lines stream producer
 * @see https://jsonlines.org/
 */ function jsonlStreamProducer(opts) {
    let [head, stream] = createBatchStreamProducer(opts);
    const { serialize } = opts;
    if (serialize) {
        head = serialize(head);
        stream = stream.pipeThrough(new TransformStream({
            transform (chunk, controller) {
                controller.enqueue(serialize(chunk));
            }
        }));
    }
    return stream.pipeThrough(new TransformStream({
        start (controller) {
            controller.enqueue(JSON.stringify(head) + '\n');
        },
        transform (chunk, controller) {
            controller.enqueue(JSON.stringify(chunk) + '\n');
        }
    })).pipeThrough(new TextEncoderStream());
}
class StreamInterruptedError extends Error {
    constructor(cause){
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore https://github.com/tc39/proposal-error-cause
        super('Invalid response or stream interrupted', {
            cause
        });
    }
}
class AsyncError extends Error {
    constructor(data){
        super('Received error from server'), _define_property._(this, "data", void 0), this.data = data;
    }
}
const nodeJsStreamToReaderEsque = (source)=>{
    return {
        getReader () {
            const { readable, controller } = createReadableStream.createReadableStream();
            source.on('data', (chunk)=>{
                controller.enqueue(chunk);
            });
            source.on('end', ()=>{
                controller.close();
            });
            source.on('error', (error)=>{
                controller.error(error);
            });
            return readable.getReader();
        }
    };
};
function createLineAccumulator(from) {
    const reader = 'getReader' in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();
    let lineAggregate = '';
    return new ReadableStream({
        async pull (controller) {
            const { done, value } = await reader.read();
            if (done) {
                controller.close();
            } else {
                controller.enqueue(value);
            }
        },
        cancel () {
            return reader.cancel();
        }
    }).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({
        transform (chunk, controller) {
            lineAggregate += chunk;
            const parts = lineAggregate.split('\n');
            lineAggregate = parts.pop() ?? '';
            for (const part of parts){
                controller.enqueue(part);
            }
        }
    }));
}
function createConsumerStream(from) {
    const stream = createLineAccumulator(from);
    let sentHead = false;
    return stream.pipeThrough(new TransformStream({
        transform (line, controller) {
            if (!sentHead) {
                const head = JSON.parse(line);
                controller.enqueue(head);
                sentHead = true;
            } else {
                const chunk = JSON.parse(line);
                controller.enqueue(chunk);
            }
        }
    }));
}
/**
 * JSON Lines stream consumer
 * @see https://jsonlines.org/
 */ async function jsonlStreamConsumer(opts) {
    const { deserialize = (v)=>v } = opts;
    let source = createConsumerStream(opts.from);
    if (deserialize) {
        source = source.pipeThrough(new TransformStream({
            transform (chunk, controller) {
                controller.enqueue(deserialize(chunk));
            }
        }));
    }
    let headDeferred = createDeferred.createDeferred();
    /**
   * This is needed as new values can come in before the controller has read the chunk
   * Not pretty, could likely be refactored and omitted somehow
   */ const chunkDeferred = new Map();
    const controllers = new Map();
    const maybeAbort = ()=>{
        if (chunkDeferred.size === 0 && controllers.size === 0) {
            // nothing is listening to the stream anymore
            opts.abortController?.abort();
        }
    };
    function decodeChunkDefinition(value) {
        const [_path, type, chunkId] = value;
        const stream = createReadableStream.createReadableStream();
        controllers.set(chunkId, stream.controller);
        // resolve chunk deferred if it exists
        const deferred = chunkDeferred.get(chunkId);
        if (deferred) {
            deferred.resolve(stream.controller);
            chunkDeferred.delete(chunkId);
        }
        switch(type){
            case CHUNK_VALUE_TYPE_PROMISE:
                {
                    return new Promise((resolve, reject)=>{
                        // listen for next value in the stream
                        const reader = stream.readable.getReader();
                        reader.read().then((it)=>{
                            if (it.done) {
                                reject(new Error('Promise chunk ended without value'));
                                return;
                            }
                            if (it.value instanceof StreamInterruptedError) {
                                reject(it.value);
                                return;
                            }
                            const value = it.value;
                            const [_chunkId, status, data] = value;
                            switch(status){
                                case PROMISE_STATUS_FULFILLED:
                                    resolve(decode(data));
                                    break;
                                case PROMISE_STATUS_REJECTED:
                                    reject(opts.formatError?.({
                                        error: data
                                    }) ?? new AsyncError(data));
                                    break;
                            }
                        }).catch(reject).finally(()=>{
                            controllers.delete(chunkId);
                            maybeAbort();
                        });
                    });
                }
            case CHUNK_VALUE_TYPE_ASYNC_ITERABLE:
                {
                    const reader = stream.readable.getReader();
                    const iterator = {
                        next: async ()=>{
                            const { done, value } = await reader.read();
                            if (value instanceof StreamInterruptedError) {
                                throw value;
                            }
                            if (done) {
                                controllers.delete(chunkId);
                                maybeAbort();
                                return {
                                    done: true,
                                    value: undefined
                                };
                            }
                            const [_chunkId, status, data] = value;
                            switch(status){
                                case ASYNC_ITERABLE_STATUS_VALUE:
                                    return {
                                        done: false,
                                        value: decode(data)
                                    };
                                case ASYNC_ITERABLE_STATUS_RETURN:
                                    controllers.delete(chunkId);
                                    maybeAbort();
                                    return {
                                        done: true,
                                        value: decode(data)
                                    };
                                case ASYNC_ITERABLE_STATUS_ERROR:
                                    controllers.delete(chunkId);
                                    maybeAbort();
                                    throw opts.formatError?.({
                                        error: data
                                    }) ?? new AsyncError(data);
                            }
                        },
                        return: async ()=>{
                            controllers.delete(chunkId);
                            maybeAbort();
                            return {
                                done: true,
                                value: undefined
                            };
                        }
                    };
                    return {
                        [Symbol.asyncIterator]: ()=>iterator
                    };
                }
        }
    }
    function decode(value) {
        const [[data], ...asyncProps] = value;
        for (const value of asyncProps){
            const [key] = value;
            const decoded = decodeChunkDefinition(value);
            if (key === null) {
                return decoded;
            }
            data[key] = decoded;
        }
        return data;
    }
    const closeOrAbort = (reason)=>{
        const error = new StreamInterruptedError(reason);
        headDeferred?.reject(error);
        for (const controller of controllers.values()){
            controller.enqueue(error);
            controller.close();
        }
        controllers.clear();
    };
    source.pipeTo(new WritableStream({
        async write (chunkOrHead) {
            if (headDeferred) {
                const head = chunkOrHead;
                for (const [key, value] of Object.entries(chunkOrHead)){
                    const parsed = decode(value);
                    head[key] = parsed;
                }
                headDeferred.resolve(head);
                headDeferred = null;
                return;
            }
            const chunk = chunkOrHead;
            const [idx] = chunk;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            let readController = controllers.get(idx);
            if (!readController) {
                let deferred = chunkDeferred.get(idx);
                if (!deferred) {
                    deferred = createDeferred.createDeferred();
                    chunkDeferred.set(idx, deferred);
                }
                readController = await deferred.promise;
            }
            readController.enqueue(chunk);
        },
        close: closeOrAbort,
        abort: closeOrAbort
    }), {
        signal: opts.abortController.signal
    }).catch((error)=>{
        opts.onError?.({
            error
        });
        closeOrAbort(error);
    });
    return [
        await headDeferred.promise,
        {
            controllers
        }
    ];
}

exports.isPromise = isPromise;
exports.jsonlStreamConsumer = jsonlStreamConsumer;
exports.jsonlStreamProducer = jsonlStreamProducer;
